<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AnkiMate - Local Flashcard Study Tool</title>
    <meta name="description" content="Master any subject with spaced repetition. AnkiMate is a local flashcard study tool with comprehensive analytics and time tracking.">
    <meta name="keywords" content="flashcards, spaced repetition, study tool, learning, education, memory, anki">
    <meta name="author" content="Parthiv Koli">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ankimate.vercel.app/">
    <meta property="og:title" content="AnkiMate - Local Flashcard Study Tool">
    <meta property="og:description" content="Master any subject with spaced repetition. Comprehensive analytics and time tracking included.">
    <meta property="og:image" content="https://ankimate.vercel.app/og-image.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://ankimate.vercel.app/">
    <meta property="twitter:title" content="AnkiMate - Local Flashcard Study Tool">
    <meta property="twitter:description" content="Master any subject with spaced repetition. Comprehensive analytics and time tracking included.">
    <meta property="twitter:image" content="https://ankimate.vercel.app/og-image.png">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#3b82f6">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="AnkiMate">

    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
    
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        blue: {
                            50: '#eff6ff',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8'
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50 font-sans">
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // Local Storage Manager
        const StorageManager = {
            STORAGE_KEY: 'ankimate_local_data',
            
            saveData(data) {
                try {
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                } catch (error) {
                    console.error('Failed to save data:', error);
                }
            },
            
            loadData() {
                try {
                    const data = localStorage.getItem(this.STORAGE_KEY);
                    return data ? JSON.parse(data) : this.getInitialData();
                } catch (error) {
                    console.error('Failed to load data:', error);
                    return this.getInitialData();
                }
            },
            
            getInitialData() {
                return {
                    decks: [
                        {
                            id: '1',
                            name: 'Sample Deck - Basic Math',
                            createdAt: Date.now(),
                            cards: [
                                {
                                    id: '1',
                                    front: 'What is 2 + 2?',
                                    back: '4',
                                    nextReview: Date.now(),
                                    interval: 1,
                                    correctCount: 0,
                                    incorrectCount: 0
                                },
                                {
                                    id: '2',
                                    front: 'What is 5 ร 3?',
                                    back: '15',
                                    nextReview: Date.now(),
                                    interval: 1,
                                    correctCount: 0,
                                    incorrectCount: 0
                                },
                                {
                                    id: '3',
                                    front: 'What is 10 รท 2?',
                                    back: '5',
                                    nextReview: Date.now(),
                                    interval: 1,
                                    correctCount: 0,
                                    incorrectCount: 0
                                }
                            ]
                        }
                    ]
                };
            }
        };

        // Spaced Repetition Algorithm
        const SpacedRepetition = {
            intervals: [1, 3, 7, 14, 30], // days
            
            calculateNextReview(card, isCorrect) {
                const now = Date.now();
                const dayInMs = 24 * 60 * 60 * 1000;
                
                if (isCorrect) {
                    const currentIndex = this.intervals.indexOf(card.interval);
                    const nextIndex = Math.min(currentIndex + 1, this.intervals.length - 1);
                    const newInterval = this.intervals[nextIndex];
                    
                    return {
                        nextReview: now + (newInterval * dayInMs),
                        interval: newInterval,
                        correctCount: card.correctCount + 1,
                        incorrectCount: card.incorrectCount
                    };
                } else {
                    return {
                        nextReview: now + dayInMs, // Reset to 1 day
                        interval: 1,
                        correctCount: card.correctCount,
                        incorrectCount: card.incorrectCount + 1
                    };
                }
            },
            
            getDueCards(cards) {
                const now = Date.now();
                return cards.filter(card => card.nextReview <= now);
            },
            
            getStats(cards) {
                const now = Date.now();
                const dueCards = this.getDueCards(cards);
                const totalCorrect = cards.reduce((sum, card) => sum + card.correctCount, 0);
                const totalIncorrect = cards.reduce((sum, card) => sum + card.incorrectCount, 0);
                const totalStudied = totalCorrect + totalIncorrect;
                
                return {
                    totalCards: cards.length,
                    dueCards: dueCards.length,
                    totalStudied,
                    correctPercentage: totalStudied > 0 ? Math.round((totalCorrect / totalStudied) * 100) : 0
                };
            }
        };

        // Analytics and Study Tracking
        const Analytics = {
            // Track a study session
            recordStudySession(deckId, cardsStudied, correctAnswers, incorrectAnswers) {
                const today = new Date().toDateString();
                const sessionData = {
                    date: today,
                    timestamp: Date.now(),
                    deckId,
                    cardsStudied,
                    correctAnswers,
                    incorrectAnswers,
                    accuracy: cardsStudied > 0 ? Math.round((correctAnswers / cardsStudied) * 100) : 0
                };
                
                // Get existing sessions
                const sessions = this.getStudySessions();
                sessions.push(sessionData);
                
                // Keep only last 365 days of data
                const oneYearAgo = Date.now() - (365 * 24 * 60 * 60 * 1000);
                const filteredSessions = sessions.filter(session => session.timestamp > oneYearAgo);
                
                // Save updated sessions
                try {
                    localStorage.setItem('ankimate_study_sessions', JSON.stringify(filteredSessions));
                } catch (error) {
                    console.error('Failed to save study session:', error);
                }
            },
            
            // Get all study sessions
            getStudySessions() {
                try {
                    const sessions = localStorage.getItem('ankimate_study_sessions');
                    return sessions ? JSON.parse(sessions) : [];
                } catch (error) {
                    console.error('Failed to load study sessions:', error);
                    return [];
                }
            },
            
            // Calculate current study streak
            getStudyStreak() {
                const sessions = this.getStudySessions();
                if (sessions.length === 0) return 0;
                
                // Group sessions by date
                const sessionsByDate = {};
                sessions.forEach(session => {
                    sessionsByDate[session.date] = true;
                });
                
                const dates = Object.keys(sessionsByDate).sort((a, b) => new Date(b) - new Date(a));
                let streak = 0;
                const today = new Date().toDateString();
                const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();
                
                // Check if studied today or yesterday (to account for different time zones)
                if (dates.length > 0 && (dates[0] === today || dates[0] === yesterday)) {
                    streak = 1;
                    
                    // Count consecutive days
                    for (let i = 1; i < dates.length; i++) {
                        const currentDate = new Date(dates[i]);
                        const previousDate = new Date(dates[i - 1]);
                        const dayDiff = Math.floor((previousDate - currentDate) / (24 * 60 * 60 * 1000));
                        
                        if (dayDiff === 1) {
                            streak++;
                        } else {
                            break;
                        }
                    }
                }
                
                return streak;
            },
            
            // Get today's study progress
            getTodayProgress() {
                const today = new Date().toDateString();
                const sessions = this.getStudySessions().filter(session => session.date === today);
                
                return sessions.reduce((total, session) => ({
                    cardsStudied: total.cardsStudied + session.cardsStudied,
                    correctAnswers: total.correctAnswers + session.correctAnswers,
                    incorrectAnswers: total.incorrectAnswers + session.incorrectAnswers,
                    sessionsCount: total.sessionsCount + 1
                }), { cardsStudied: 0, correctAnswers: 0, incorrectAnswers: 0, sessionsCount: 0 });
            },
            
            // Get weekly progress
            getWeeklyProgress() {
                const weekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
                const sessions = this.getStudySessions().filter(session => session.timestamp > weekAgo);
                
                const dailyStats = {};
                for (let i = 6; i >= 0; i--) {
                    const date = new Date(Date.now() - (i * 24 * 60 * 60 * 1000)).toDateString();
                    dailyStats[date] = { cardsStudied: 0, accuracy: 0, sessionsCount: 0 };
                }
                
                sessions.forEach(session => {
                    if (dailyStats[session.date]) {
                        dailyStats[session.date].cardsStudied += session.cardsStudied;
                        dailyStats[session.date].sessionsCount += 1;
                    }
                });
                
                // Calculate daily accuracy
                Object.keys(dailyStats).forEach(date => {
                    const daySessions = sessions.filter(s => s.date === date);
                    if (daySessions.length > 0) {
                        const totalCorrect = daySessions.reduce((sum, s) => sum + s.correctAnswers, 0);
                        const totalStudied = daySessions.reduce((sum, s) => sum + s.cardsStudied, 0);
                        dailyStats[date].accuracy = totalStudied > 0 ? Math.round((totalCorrect / totalStudied) * 100) : 0;
                    }
                });
                
                return dailyStats;
            },
            
            // Get performance analytics
            getPerformanceAnalytics(decks) {
                const sessions = this.getStudySessions();
                const deckStats = {};
                
                // Initialize deck stats
                decks.forEach(deck => {
                    deckStats[deck.id] = {
                        name: deck.name,
                        totalSessions: 0,
                        totalCardsStudied: 0,
                        totalCorrect: 0,
                        totalIncorrect: 0,
                        averageAccuracy: 0,
                        lastStudied: null
                    };
                });
                
                // Calculate stats from sessions
                sessions.forEach(session => {
                    if (deckStats[session.deckId]) {
                        const stats = deckStats[session.deckId];
                        stats.totalSessions++;
                        stats.totalCardsStudied += session.cardsStudied;
                        stats.totalCorrect += session.correctAnswers;
                        stats.totalIncorrect += session.incorrectAnswers;
                        stats.lastStudied = Math.max(stats.lastStudied || 0, session.timestamp);
                    }
                });
                
                // Calculate average accuracy
                Object.values(deckStats).forEach(stats => {
                    const totalAnswered = stats.totalCorrect + stats.totalIncorrect;
                    stats.averageAccuracy = totalAnswered > 0 ? Math.round((stats.totalCorrect / totalAnswered) * 100) : 0;
                });
                
                return deckStats;
            }
        };

        // File Utils
        const FileUtils = {
            exportDeck(deck) {
                const dataStr = JSON.stringify(deck, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `${deck.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            },
            
            importDeck(file, callback) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const deck = JSON.parse(e.target.result);
                        if (deck.name && Array.isArray(deck.cards)) {
                            deck.id = Date.now().toString();
                            deck.createdAt = Date.now();
                            deck.cards = deck.cards.map((card, index) => ({
                                id: `${deck.id}_${index}`,
                                front: card.front || '',
                                back: card.back || '',
                                nextReview: Date.now(),
                                interval: 1,
                                correctCount: 0,
                                incorrectCount: 0,
                                ...card
                            }));
                            callback(null, deck);
                        } else {
                            callback(new Error('Invalid deck format'));
                        }
                    } catch (error) {
                        callback(new Error('Failed to parse JSON file'));
                    }
                };
                reader.readAsText(file);
            }
        };

        // Modal Component
        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div className="bg-white rounded-lg shadow-xl max-w-md w-full max-h-[90vh] overflow-y-auto">
                        <div className="flex justify-between items-center p-6 border-b">
                            <h2 className="text-xl font-semibold text-gray-900">{title}</h2>
                            <button 
                                onClick={onClose}
                                className="text-gray-400 hover:text-gray-600 text-2xl"
                                aria-label="Close modal"
                            >
                                ร
                            </button>
                        </div>
                        <div className="p-6">{children}</div>
                    </div>
                </div>
            );
        };

        // Deck Form Component
        const DeckForm = ({ deck, onSave, onCancel }) => {
            const [name, setName] = useState(deck?.name || '');
            
            const handleSave = () => {
                if (name.trim()) {
                    onSave({
                        ...deck,
                        name: name.trim(),
                        id: deck?.id || Date.now().toString(),
                        cards: deck?.cards || [],
                        createdAt: deck?.createdAt || Date.now()
                    });
                }
            };
            
            return (
                <div className="space-y-4">
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            Deck Name
                        </label>
                        <input
                            type="text"
                            value={name}
                            onChange={(e) => setName(e.target.value)}
                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            placeholder="Enter deck name..."
                            autoFocus
                        />
                    </div>
                    <div className="flex justify-end gap-3 pt-4">
                        <button 
                            onClick={onCancel}
                            className="px-4 py-2 text-gray-600 hover:text-gray-800 transition-colors"
                        >
                            Cancel
                        </button>
                        <button
                            onClick={handleSave}
                            disabled={!name.trim()}
                            className={`px-6 py-2 rounded-lg font-medium transition-colors ${
                                name.trim() 
                                    ? 'bg-blue-500 text-white hover:bg-blue-600' 
                                    : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                            }`}
                        >
                            {deck ? 'Update Deck' : 'Create Deck'}
                        </button>
                    </div>
                </div>
            );
        };

        // Card Form Component
        const CardForm = ({ card, onSave, onCancel }) => {
            const [front, setFront] = useState(card?.front || '');
            const [back, setBack] = useState(card?.back || '');
            
            const handleSave = () => {
                if (front.trim() && back.trim()) {
                    onSave({
                        ...card,
                        front: front.trim(),
                        back: back.trim(),
                        id: card?.id || Date.now().toString()
                    });
                }
            };
            
            return (
                <div className="space-y-4">
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            Front (Question)
                        </label>
                        <textarea
                            value={front}
                            onChange={(e) => setFront(e.target.value)}
                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            rows="3"
                            placeholder="Enter the question..."
                        />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            Back (Answer)
                        </label>
                        <textarea
                            value={back}
                            onChange={(e) => setBack(e.target.value)}
                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            rows="3"
                            placeholder="Enter the answer..."
                        />
                    </div>
                    <div className="flex justify-end gap-3 pt-4">
                        <button 
                            onClick={onCancel}
                            className="px-4 py-2 text-gray-600 hover:text-gray-800 transition-colors"
                        >
                            Cancel
                        </button>
                        <button
                            onClick={handleSave}
                            disabled={!front.trim() || !back.trim()}
                            className={`px-6 py-2 rounded-lg font-medium transition-colors ${
                                front.trim() && back.trim()
                                    ? 'bg-blue-500 text-white hover:bg-blue-600' 
                                    : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                            }`}
                        >
                            {card ? 'Update Card' : 'Add Card'}
                        </button>
                    </div>
                </div>
            );
        };

        // Sidebar Component
        const Sidebar = ({ decks, selectedDeckId, onSelectDeck, onCreateDeck, onImportDeck, onViewDashboard }) => {
            const handleImportClick = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        FileUtils.importDeck(file, (error, deck) => {
                            if (error) {
                                alert('Error importing deck: ' + error.message);
                            } else {
                                onImportDeck(deck);
                            }
                        });
                    }
                };
                input.click();
            };
            
            return (
                <div className="w-64 bg-white shadow-lg h-screen flex flex-col">
                    <div className="p-6 border-b">
                        <h1 className="text-2xl font-bold text-blue-600">AnkiMate</h1>
                        <p className="text-sm text-gray-600 mt-1">Local Study Tool</p>
                    </div>
                    
                    <div className="p-4 border-b">
                        <button
                            onClick={onCreateDeck}
                            className="w-full bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors mb-2"
                        >
                            Create New Deck
                        </button>
                        <button
                            onClick={handleImportClick}
                            className="w-full bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition-colors mb-2"
                        >
                            Import Deck
                        </button>
                        <button
                            onClick={onViewDashboard}
                            className="w-full bg-purple-500 text-white px-4 py-2 rounded-lg hover:bg-purple-600 transition-colors"
                        >
                            ๐ Dashboard
                        </button>
                    </div>
                    
                    <div className="flex-1 overflow-y-auto">
                        <div className="p-4">
                            <h3 className="text-sm font-medium text-gray-700 mb-3">Your Decks</h3>
                            {decks.length === 0 ? (
                                <p className="text-gray-500 text-sm">No decks yet. Create your first deck!</p>
                            ) : (
                                <div className="space-y-2">
                                    {decks.map(deck => {
                                        const stats = SpacedRepetition.getStats(deck.cards);
                                        return (
                                            <button
                                                key={deck.id}
                                                onClick={() => onSelectDeck(deck.id)}
                                                className={`w-full text-left p-3 rounded-lg transition-colors ${
                                                    selectedDeckId === deck.id
                                                        ? 'bg-blue-50 border-2 border-blue-200'
                                                        : 'bg-gray-50 hover:bg-gray-100 border-2 border-transparent'
                                                }`}
                                            >
                                                <div className="font-medium text-gray-900">{deck.name}</div>
                                                <div className="text-sm text-gray-600 mt-1">
                                                    {stats.totalCards} cards โข {stats.dueCards} due
                                                </div>
                                            </button>
                                        );
                                    })}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Home Screen Component
        const HomeScreen = ({ decks, onSelectDeck, onCreateDeck, onImportDeck }) => {
            const handleImportClick = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        FileUtils.importDeck(file, (error, deck) => {
                            if (error) {
                                alert('Error importing deck: ' + error.message);
                            } else {
                                onImportDeck(deck);
                            }
                        });
                    }
                };
                input.click();
            };
            
            return (
                <div className="max-w-4xl mx-auto p-6">
                    <div className="text-center mb-8">
                        <h1 className="text-4xl font-bold text-gray-900 mb-2">Welcome to AnkiMate</h1>
                        <p className="text-xl text-gray-600">Master any subject with spaced repetition</p>
                        <p className="text-sm text-gray-500 mt-2">All data stored locally in your browser</p>
                    </div>
                    
                    <div className="flex justify-center gap-4 mb-8">
                        <button
                            onClick={onCreateDeck}
                            className="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 transition-colors font-medium"
                        >
                            Create New Deck
                        </button>
                        <button
                            onClick={handleImportClick}
                            className="bg-gray-500 text-white px-6 py-3 rounded-lg hover:bg-gray-600 transition-colors font-medium"
                        >
                            Import Deck
                        </button>
                    </div>
                    
                    {decks.length > 0 && (
                        <div>
                            <h2 className="text-2xl font-semibold text-gray-900 mb-6">Your Decks</h2>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                {decks.map(deck => {
                                    const stats = SpacedRepetition.getStats(deck.cards);
                                    return (
                                        <div
                                            key={deck.id}
                                            className="bg-white rounded-lg shadow-md p-6 hover:shadow-lg transition-shadow cursor-pointer"
                                            onClick={() => onSelectDeck(deck.id)}
                                        >
                                            <h3 className="text-xl font-semibold text-gray-900 mb-3">{deck.name}</h3>
                                            <div className="space-y-2 text-sm text-gray-600">
                                                <div className="flex justify-between">
                                                    <span>Total Cards:</span>
                                                    <span className="font-medium">{stats.totalCards}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                    <span>Due for Review:</span>
                                                    <span className="font-medium text-blue-600">{stats.dueCards}</span>
                                                </div>
                                                <div className="flex justify-between">
                                                    <span>Accuracy:</span>
                                                    <span className="font-medium">{stats.correctPercentage}%</span>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Deck View Component
        const DeckView = ({ deck, onUpdateDeck, onDeleteDeck, onStartStudy, onAddCard, onEditCard, onDeleteCard }) => {
            const stats = SpacedRepetition.getStats(deck.cards);
            
            const handleExport = () => {
                FileUtils.exportDeck(deck);
            };
            
            return (
                <div className="max-w-4xl mx-auto p-6">
                    <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                        <div className="flex justify-between items-start mb-4">
                            <div>
                                <h1 className="text-3xl font-bold text-gray-900 mb-2">{deck.name}</h1>
                                <p className="text-gray-600">Created {new Date(deck.createdAt).toLocaleDateString()}</p>
                            </div>
                            <div className="flex gap-2">
                                <button
                                    onClick={handleExport}
                                    className="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition-colors"
                                >
                                    Export
                                </button>
                                <button
                                    onClick={() => onDeleteDeck(deck.id)}
                                    className="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors"
                                >
                                    Delete Deck
                                </button>
                            </div>
                        </div>
                        
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                            <div className="bg-blue-50 p-4 rounded-lg text-center">
                                <div className="text-2xl font-bold text-blue-600">{stats.totalCards}</div>
                                <div className="text-sm text-blue-800">Total Cards</div>
                            </div>
                            <div className="bg-orange-50 p-4 rounded-lg text-center">
                                <div className="text-2xl font-bold text-orange-600">{stats.dueCards}</div>
                                <div className="text-sm text-orange-800">Due for Review</div>
                            </div>
                            <div className="bg-green-50 p-4 rounded-lg text-center">
                                <div className="text-2xl font-bold text-green-600">{stats.correctPercentage}%</div>
                                <div className="text-sm text-green-800">Accuracy</div>
                            </div>
                            <div className="bg-purple-50 p-4 rounded-lg text-center">
                                <div className="text-2xl font-bold text-purple-600">{stats.totalStudied}</div>
                                <div className="text-sm text-purple-800">Cards Studied</div>
                            </div>
                        </div>
                        
                        <div className="flex gap-4">
                            <button
                                onClick={onStartStudy}
                                disabled={stats.dueCards === 0}
                                className={`px-6 py-3 rounded-lg font-medium transition-colors ${
                                    stats.dueCards > 0
                                        ? 'bg-blue-500 text-white hover:bg-blue-600'
                                        : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                }`}
                            >
                                {stats.dueCards > 0 ? `Study Now (${stats.dueCards} cards)` : 'No cards due'}
                            </button>
                            <button
                                onClick={onAddCard}
                                className="bg-green-500 text-white px-6 py-3 rounded-lg hover:bg-green-600 transition-colors font-medium"
                            >
                                Add Card
                            </button>
                        </div>
                    </div>
                    
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold text-gray-900 mb-4">Cards</h2>
                        {deck.cards.length === 0 ? (
                            <p className="text-gray-500 text-center py-8">No cards yet. Add your first card!</p>
                        ) : (
                            <div className="space-y-4">
                                {deck.cards.map(card => {
                                    const isDue = card.nextReview <= Date.now();
                                    return (
                                        <div key={card.id} className="border rounded-lg p-4">
                                            <div className="flex justify-between items-start mb-2">
                                                <div className="flex-1">
                                                    <div className="font-medium text-gray-900 mb-1">Q: {card.front}</div>
                                                    <div className="text-gray-600">A: {card.back}</div>
                                                </div>
                                                <div className="flex gap-2 ml-4">
                                                    <button
                                                        onClick={() => onEditCard(card)}
                                                        className="text-blue-600 hover:text-blue-800 px-2 py-1 text-sm"
                                                    >
                                                        Edit
                                                    </button>
                                                    <button
                                                        onClick={() => onDeleteCard(card.id)}
                                                        className="text-red-600 hover:text-red-800 px-2 py-1 text-sm"
                                                    >
                                                        Delete
                                                    </button>
                                                </div>
                                            </div>
                                            <div className="flex justify-between items-center text-sm text-gray-500">
                                                <span>Correct: {card.correctCount} | Incorrect: {card.incorrectCount}</span>
                                                <span className={isDue ? 'text-orange-600 font-medium' : ''}>
                                                    {isDue ? 'Due now' : `Next review: ${new Date(card.nextReview).toLocaleDateString()}`}
                                                </span>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Study Mode Component
        const StudyMode = ({ deck, onComplete, onUpdateCard }) => {
            const [currentCardIndex, setCurrentCardIndex] = useState(0);
            const [showAnswer, setShowAnswer] = useState(false);
            const [sessionStats, setSessionStats] = useState({ correct: 0, incorrect: 0 });
            
            const dueCards = SpacedRepetition.getDueCards(deck.cards);
            const currentCard = dueCards[currentCardIndex];
            
            useEffect(() => {
                const handleKeyPress = (e) => {
                    if (e.key === 'Enter' && !showAnswer) {
                        setShowAnswer(true);
                    }
                };
                
                window.addEventListener('keydown', handleKeyPress);
                return () => window.removeEventListener('keydown', handleKeyPress);
            }, [showAnswer]);
            
            if (!currentCard) {
                // Record the final session when study is complete
                useEffect(() => {
                    if (sessionStats.correct + sessionStats.incorrect > 0) {
                        Analytics.recordStudySession(
                            deck.id,
                            sessionStats.correct + sessionStats.incorrect,
                            sessionStats.correct,
                            sessionStats.incorrect
                        );
                    }
                }, []);

                return (
                    <div className="max-w-2xl mx-auto p-6 text-center">
                        <div className="bg-white rounded-lg shadow-md p-8">
                            <h2 className="text-2xl font-bold text-gray-900 mb-4">Study Session Complete! ๐</h2>
                            <div className="text-lg text-gray-600 mb-6">
                                <p>Correct: {sessionStats.correct}</p>
                                <p>Incorrect: {sessionStats.incorrect}</p>
                                <p>Accuracy: {sessionStats.correct + sessionStats.incorrect > 0 
                                    ? Math.round((sessionStats.correct / (sessionStats.correct + sessionStats.incorrect)) * 100) 
                                    : 0}%</p>
                            </div>
                            <div className="mb-6">
                                <div className="text-sm text-gray-500 mb-2">Session Progress</div>
                                <div className="w-full bg-gray-200 rounded-full h-3">
                                    <div 
                                        className="bg-green-500 h-3 rounded-full transition-all duration-300"
                                        style={{ 
                                            width: `${sessionStats.correct + sessionStats.incorrect > 0 
                                                ? (sessionStats.correct / (sessionStats.correct + sessionStats.incorrect)) * 100 
                                                : 0}%` 
                                        }}
                                    ></div>
                                </div>
                            </div>
                            <button
                                onClick={onComplete}
                                className="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 transition-colors"
                            >
                                Back to Deck
                            </button>
                        </div>
                    </div>
                );
            }
            
            const handleAnswer = (isCorrect) => {
                const updatedCard = {
                    ...currentCard,
                    ...SpacedRepetition.calculateNextReview(currentCard, isCorrect)
                };
                
                onUpdateCard(updatedCard);
                setSessionStats(prev => ({
                    correct: prev.correct + (isCorrect ? 1 : 0),
                    incorrect: prev.incorrect + (isCorrect ? 0 : 1)
                }));
                
                if (currentCardIndex < dueCards.length - 1) {
                    setCurrentCardIndex(prev => prev + 1);
                    setShowAnswer(false);
                } else {
                    // Record study session when complete
                    const finalStats = {
                        correct: sessionStats.correct + (isCorrect ? 1 : 0),
                        incorrect: sessionStats.incorrect + (isCorrect ? 0 : 1)
                    };
                    
                    Analytics.recordStudySession(
                        deck.id,
                        finalStats.correct + finalStats.incorrect,
                        finalStats.correct,
                        finalStats.incorrect
                    );
                    
                    setTimeout(() => {
                        onComplete();
                    }, 1000);
                }
            };
            
            const progress = ((currentCardIndex + 1) / dueCards.length) * 100;
            
            return (
                <div className="max-w-2xl mx-auto p-6">
                    <div className="mb-6">
                        <div className="flex justify-between items-center mb-2">
                            <span className="text-sm text-gray-600">
                                Card {currentCardIndex + 1} of {dueCards.length}
                            </span>
                            <button 
                                onClick={onComplete}
                                className="text-gray-600 hover:text-gray-800 text-sm"
                            >
                                Exit Study
                            </button>
                        </div>
                        <div className="w-full bg-gray-200 rounded-full h-2">
                            <div 
                                className="bg-blue-500 h-2 rounded-full transition-all duration-300"
                                style={{ width: `${progress}%` }}
                            ></div>
                        </div>
                    </div>
                    
                    <div className="bg-white rounded-lg shadow-lg p-8 min-h-[400px] flex flex-col justify-center">
                        <div className="text-center mb-8">
                            <h2 className="text-2xl font-bold text-gray-900 mb-6">{currentCard.front}</h2>
                            
                            {showAnswer ? (
                                <div>
                                    <div className="text-xl text-gray-700 mb-8 p-4 bg-gray-50 rounded-lg">
                                        {currentCard.back}
                                    </div>
                                    <div className="flex justify-center gap-4">
                                        <button
                                            onClick={() => handleAnswer(false)}
                                            className="bg-red-500 text-white px-8 py-3 rounded-lg hover:bg-red-600 transition-colors font-medium"
                                        >
                                            Incorrect
                                        </button>
                                        <button
                                            onClick={() => handleAnswer(true)}
                                            className="bg-green-500 text-white px-8 py-3 rounded-lg hover:bg-green-600 transition-colors font-medium"
                                        >
                                            Correct
                                        </button>
                                    </div>
                                </div>
                            ) : (
                                <button
                                    onClick={() => setShowAnswer(true)}
                                    className="bg-blue-500 text-white px-8 py-3 rounded-lg hover:bg-blue-600 transition-colors font-medium"
                                >
                                    Show Answer
                                </button>
                            )}
                        </div>
                        
                        {!showAnswer && (
                            <p className="text-center text-gray-500 text-sm">
                                Press Enter to reveal the answer
                            </p>
                        )}
                    </div>
                    
                    <div className="mt-6 text-center text-sm text-gray-600">
                        Session Progress: {sessionStats.correct} correct, {sessionStats.incorrect} incorrect
                    </div>
                </div>
            );
        };

        // Dashboard Component
        const Dashboard = ({ decks, onViewDecks }) => {
            const studyStreak = Analytics.getStudyStreak();
            const todayProgress = Analytics.getTodayProgress();
            const weeklyProgress = Analytics.getWeeklyProgress();
            const performanceAnalytics = Analytics.getPerformanceAnalytics(decks);
            
            const weeklyData = Object.entries(weeklyProgress).map(([date, data]) => ({
                date,
                cardsStudied: data.cardsStudied,
                accuracy: data.accuracy
            }));
            
            return (
                <div className="max-w-5xl mx-auto p-6">
                    <div className="flex justify-between items-center mb-8">
                        <h1 className="text-3xl font-bold text-gray-900">Dashboard</h1>
                        <button
                            onClick={onViewDecks}
                            className="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 transition-colors font-medium"
                        >
                            Back to Decks
                        </button>
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                        <div className="bg-white rounded-lg shadow-md p-6">
                            <h2 className="text-xl font-semibold text-gray-900 mb-3">Study Streak</h2>
                            <div className="text-4xl font-bold text-blue-600">{studyStreak} days</div>
                            <p className="text-gray-600">Keep up the great work!</p>
                        </div>
                        
                        <div className="bg-white rounded-lg shadow-md p-6">
                            <h2 className="text-xl font-semibold text-gray-900 mb-3">Today's Progress</h2>
                            <div className="text-2xl font-bold text-green-600">{todayProgress.cardsStudied} cards</div>
                            <p className="text-gray-600">Sessions: {todayProgress.sessionsCount}</p>
                            <p className="text-gray-600">Correct: {todayProgress.correctAnswers}, Incorrect: {todayProgress.incorrectAnswers}</p>
                        </div>
                        
                        <div className="bg-white rounded-lg shadow-md p-6">
                            <h2 className="text-xl font-semibold text-gray-900 mb-3">Weekly Progress</h2>
                            {weeklyData.map((day, index) => (
                                <div key={index} className="flex justify-between text-gray-600">
                                    <span>{new Date(day.date).toLocaleDateString()}</span>
                                    <span>{day.cardsStudied} cards ({day.accuracy}%)</span>
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    <div>
                        <h2 className="text-2xl font-semibold text-gray-900 mb-4">Deck Performance</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            {Object.values(performanceAnalytics).map(deck => (
                                <div key={deck.name} className="bg-white rounded-lg shadow-md p-6">
                                    <h3 className="text-xl font-semibold text-gray-900 mb-3">{deck.name}</h3>
                                    <p className="text-gray-600">Total Sessions: {deck.totalSessions}</p>
                                    <p className="text-gray-600">Cards Studied: {deck.totalCardsStudied}</p>
                                    <p className="text-gray-600">Average Accuracy: {deck.averageAccuracy}%</p>
                                    {deck.lastStudied && (
                                        <p className="text-gray-600">Last Studied: {new Date(deck.lastStudied).toLocaleDateString()}</p>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // Main App Component
        const App = () => {
            const [data, setData] = useState({ decks: [] });
            const [selectedDeckId, setSelectedDeckId] = useState(null);
            const [currentView, setCurrentView] = useState('home');
            const [showDeckForm, setShowDeckForm] = useState(false);
            const [showCardForm, setShowCardForm] = useState(false);
            const [editingCard, setEditingCard] = useState(null);
            
            // Load data on mount
            useEffect(() => {
                const loadedData = StorageManager.loadData();
                setData(loadedData);
            }, []);
            
            // Save data whenever it changes
            useEffect(() => {
                StorageManager.saveData(data);
            }, [data]);
            
            const selectedDeck = data.decks.find(deck => deck.id === selectedDeckId);
            
            // Deck operations
            const handleCreateDeck = () => {
                setShowDeckForm(true);
            };
            
            const handleSaveDeck = (deck) => {
                setData(prev => ({
                    ...prev,
                    decks: deck.id && prev.decks.find(d => d.id === deck.id)
                        ? prev.decks.map(d => d.id === deck.id ? deck : d)
                        : [...prev.decks, deck]
                }));
                setShowDeckForm(false);
                if (!selectedDeckId) {
                    setSelectedDeckId(deck.id);
                    setCurrentView('deck');
                }
            };
            
            const handleDeleteDeck = (deckId) => {
                if (confirm('Are you sure you want to delete this deck?')) {
                    setData(prev => ({
                        ...prev,
                        decks: prev.decks.filter(deck => deck.id !== deckId)
                    }));
                    setSelectedDeckId(null);
                    setCurrentView('home');
                }
            };
            
            const handleImportDeck = (deck) => {
                setData(prev => ({
                    ...prev,
                    decks: [...prev.decks, deck]
                }));
                alert('Deck imported successfully!');
            };
            
            // Card operations
            const handleAddCard = () => {
                setEditingCard(null);
                setShowCardForm(true);
            };
            
            const handleEditCard = (card) => {
                setEditingCard(card);
                setShowCardForm(true);
            };
            
            const handleSaveCard = (card) => {
                setData(prev => ({
                    ...prev,
                    decks: prev.decks.map(deck => {
                        if (deck.id === selectedDeckId) {
                            const existingCardIndex = deck.cards.findIndex(c => c.id === card.id);
                            if (existingCardIndex >= 0) {
                                const updatedCards = [...deck.cards];
                                updatedCards[existingCardIndex] = { ...updatedCards[existingCardIndex], ...card };
                                return { ...deck, cards: updatedCards };
                            } else {
                                const newCard = {
                                    ...card,
                                    nextReview: Date.now(),
                                    interval: 1,
                                    correctCount: 0,
                                    incorrectCount: 0
                                };
                                return { ...deck, cards: [...deck.cards, newCard] };
                            }
                        }
                        return deck;
                    })
                }));
                setShowCardForm(false);
                setEditingCard(null);
            };
            
            const handleDeleteCard = (cardId) => {
                if (confirm('Are you sure you want to delete this card?')) {
                    setData(prev => ({
                        ...prev,
                        decks: prev.decks.map(deck => {
                            if (deck.id === selectedDeckId) {
                                return { ...deck, cards: deck.cards.filter(card => card.id !== cardId) };
                            }
                            return deck;
                        })
                    }));
                }
            };
            
            const handleUpdateCard = (updatedCard) => {
                setData(prev => ({
                    ...prev,
                    decks: prev.decks.map(deck => {
                        if (deck.id === selectedDeckId) {
                            return {
                                ...deck,
                                cards: deck.cards.map(card => 
                                    card.id === updatedCard.id ? updatedCard : card
                                )
                            };
                        }
                        return deck;
                    })
                }));
            };
            
            // Navigation
            const handleSelectDeck = (deckId) => {
                setSelectedDeckId(deckId);
                setCurrentView('deck');
            };
            
            const handleStartStudy = () => {
                setCurrentView('study');
            };
            
            const handleCompleteStudy = () => {
                setCurrentView('deck');
            };

            const handleViewDashboard = () => {
                setCurrentView('dashboard');
            };
            
            const handleViewDecks = () => {
                setCurrentView('home');
                setSelectedDeckId(null);
            };
            
            return (
                <div className="flex h-screen bg-gray-50">
                    <Sidebar
                        decks={data.decks}
                        selectedDeckId={selectedDeckId}
                        onSelectDeck={handleSelectDeck}
                        onCreateDeck={handleCreateDeck}
                        onImportDeck={handleImportDeck}
                        onViewDashboard={handleViewDashboard}
                    />
                    
                    <div className="flex-1 overflow-y-auto">
                        {currentView === 'home' && (
                            <HomeScreen
                                decks={data.decks}
                                onSelectDeck={handleSelectDeck}
                                onCreateDeck={handleCreateDeck}
                                onImportDeck={handleImportDeck}
                            />
                        )}
                        
                        {currentView === 'deck' && selectedDeck && (
                            <DeckView
                                deck={selectedDeck}
                                onUpdateDeck={handleSaveDeck}
                                onDeleteDeck={handleDeleteDeck}
                                onStartStudy={handleStartStudy}
                                onAddCard={handleAddCard}
                                onEditCard={handleEditCard}
                                onDeleteCard={handleDeleteCard}
                            />
                        )}
                        
                        {currentView === 'study' && selectedDeck && (
                            <StudyMode
                                deck={selectedDeck}
                                onComplete={handleCompleteStudy}
                                onUpdateCard={handleUpdateCard}
                            />
                        )}

                        {currentView === 'dashboard' && (
                            <Dashboard
                                decks={data.decks}
                                onViewDecks={handleViewDecks}
                            />
                        )}
                    </div>
                    
                    <Modal 
                        isOpen={showDeckForm} 
                        onClose={() => setShowDeckForm(false)} 
                        title="Create New Deck"
                    >
                        <DeckForm 
                            onSave={handleSaveDeck} 
                            onCancel={() => setShowDeckForm(false)} 
                        />
                    </Modal>
                    
                    <Modal 
                        isOpen={showCardForm} 
                        onClose={() => {
                            setShowCardForm(false);
                            setEditingCard(null);
                        }} 
                        title={editingCard ? 'Edit Card' : 'Add New Card'}
                    >
                        <CardForm 
                            card={editingCard}
                            onSave={handleSaveCard} 
                            onCancel={() => {
                                setShowCardForm(false);
                                setEditingCard(null);
                            }} 
                        />
                    </Modal>
                </div>
            );
        };

        // Render the app
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
